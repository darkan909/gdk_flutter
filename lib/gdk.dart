// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class GdkLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  GdkLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  GdkLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int __darwin_check_fd_set_overflow(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return ___darwin_check_fd_set_overflow(
      arg0,
      arg1,
      arg2,
    );
  }

  late final ___darwin_check_fd_set_overflowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Void>,
              ffi.Int32)>>('__darwin_check_fd_set_overflow');
  late final ___darwin_check_fd_set_overflow =
      ___darwin_check_fd_set_overflowPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Perform one-time initialization of the library. This call must be made once
  /// only before calling any other GDK functions, including any functions called
  /// from other threads.
  ///
  /// :param config: The :ref:`init-config-arg`.
  int GA_init(
    ffi.Pointer<GA_json> config,
  ) {
    return _GA_init(
      config,
    );
  }

  late final _GA_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GA_json>)>>(
          'GA_init');
  late final _GA_init =
      _GA_initPtr.asFunction<int Function(ffi.Pointer<GA_json>)>();

  /// Get any error details associated with the last error on the current thread.
  ///
  /// :param output: Destination for the output :ref:`error-details` JSON.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_get_thread_error_details(
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_get_thread_error_details(
      output,
    );
  }

  late final _GA_get_thread_error_detailsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ffi.Pointer<GA_json>>)>>(
      'GA_get_thread_error_details');
  late final _GA_get_thread_error_details = _GA_get_thread_error_detailsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Create a new session.
  ///
  /// :param session: Destination for the resulting session.
  /// |     The returned session should be freed using `GA_destroy_session`.
  ///
  /// Once created, the caller should set a handler for notifications using
  /// `GA_set_notification_handler`, before calling `GA_connect` to connect the
  /// session to the network for use.
  int GA_create_session(
    ffi.Pointer<ffi.Pointer<GA_session>> session,
  ) {
    return _GA_create_session(
      session,
    );
  }

  late final _GA_create_sessionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<GA_session>>)>>('GA_create_session');
  late final _GA_create_session = _GA_create_sessionPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<GA_session>>)>();

  /// Set a handler to be called when notifications arrive for a session.
  ///
  /// :param session: The session to receive notifications for.
  /// :param handler: The handler to receive notifications.
  /// :param context: A context pointer to be passed to the handler.
  ///
  /// This call must be initially made on a session before `GA_connect`.
  /// :ref:`ntf-notifications` may arrive on different threads, so the caller
  /// must ensure that shared data is correctly locked within the handler.
  /// The ``GA_json`` object passed to the caller must be destroyed by the
  /// caller using `GA_destroy_json`. Failing to do so will result in
  /// memory leaks.
  ///
  /// Once a session has been connected, this call can be made only with null
  /// values for ``handler`` and ``context``. Once this returns, no further
  /// notifications will be delivered for the lifetime of the session.
  ///
  /// The caller should not call session functions from within the callback
  /// handler as this may block the application.
  int GA_set_notification_handler(
    ffi.Pointer<GA_session> session,
    GA_notification_handler handler,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _GA_set_notification_handler(
      session,
      handler,
      context,
    );
  }

  late final _GA_set_notification_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, GA_notification_handler,
              ffi.Pointer<ffi.Void>)>>('GA_set_notification_handler');
  late final _GA_set_notification_handler =
      _GA_set_notification_handlerPtr.asFunction<
          int Function(ffi.Pointer<GA_session>, GA_notification_handler,
              ffi.Pointer<ffi.Void>)>();

  /// Free a session allocated by `GA_create_session`.
  ///
  /// :param session: The session to free.
  ///
  /// If the session was connected using `GA_connect` then this call will
  /// disconnect it it before destroying it.
  int GA_destroy_session(
    ffi.Pointer<GA_session> session,
  ) {
    return _GA_destroy_session(
      session,
    );
  }

  late final _GA_destroy_sessionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GA_session>)>>(
          'GA_destroy_session');
  late final _GA_destroy_session = _GA_destroy_sessionPtr.asFunction<
      int Function(ffi.Pointer<GA_session>)>();

  /// Connect the session to the specified network.
  ///
  /// :param session: The session to connect.
  /// :param net_params: The :ref:`net-params` of the network to connect to.
  ///
  /// This call connects to the remote network services that the session
  /// requires, for example the Green servers or Electrum servers.
  /// `GA_connect` must be called only once per session lifetime, after
  /// `GA_create_session` and before `GA_destroy_session` respectively.
  /// Once connected, the underlying network connection of the
  /// session can be controlled using `GA_reconnect_hint`.
  ///
  /// Once the session is connected, use `GA_register_user` to create a new
  /// wallet for the session, or `GA_login_user` to open an existing wallet.
  int GA_connect(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> net_params,
  ) {
    return _GA_connect(
      session,
      net_params,
    );
  }

  late final _GA_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GA_session>, ffi.Pointer<GA_json>)>>('GA_connect');
  late final _GA_connect = _GA_connectPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>)>();

  /// Connect or disconnect a sessions underlying network connection.
  ///
  /// :param session: The session to use.
  /// :param hint: the :ref:`reconnect` describing the desired reconnection behaviour.
  int GA_reconnect_hint(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> hint,
  ) {
    return _GA_reconnect_hint(
      session,
      hint,
    );
  }

  late final _GA_reconnect_hintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>,
              ffi.Pointer<GA_json>)>>('GA_reconnect_hint');
  late final _GA_reconnect_hint = _GA_reconnect_hintPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>)>();

  /// Get the current proxy settings for the given session.
  ///
  /// :param session: The session to use.
  /// :param output: Destination for the output :ref:`proxy-info`.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_get_proxy_settings(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_get_proxy_settings(
      session,
      output,
    );
  }

  late final _GA_get_proxy_settingsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_get_proxy_settings');
  late final _GA_get_proxy_settings = _GA_get_proxy_settingsPtr.asFunction<
      int Function(
          ffi.Pointer<GA_session>, ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Compute a hashed wallet identifier from a BIP32 xpub or mnemonic.
  ///
  /// The identifier returned is computed from the network combined with the
  /// master chain code and public key of the xpub/mnemonic. It can be used
  /// as a unique wallet identifier to mitigate privacy risks associated with
  /// storing the wallet's xpub.
  ///
  /// :param net_params: The :ref:`net-params` of the network to compute an identifier for.
  /// :param params: The :ref:`wallet-id-request` to compute an identifier for.
  /// :param output: Destination for the output JSON.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_get_wallet_identifier(
    ffi.Pointer<GA_json> net_params,
    ffi.Pointer<GA_json> params,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_get_wallet_identifier(
      net_params,
      params,
      output,
    );
  }

  late final _GA_get_wallet_identifierPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_json>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_get_wallet_identifier');
  late final _GA_get_wallet_identifier =
      _GA_get_wallet_identifierPtr.asFunction<
          int Function(ffi.Pointer<GA_json>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Make a request to an http server.
  ///
  /// :param session: The session to use.
  /// :param params: the :ref:`http-params` of the server to connect to.
  /// :param output: Destination for the output JSON.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_http_request(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> params,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_http_request(
      session,
      params,
      output,
    );
  }

  late final _GA_http_requestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_http_request');
  late final _GA_http_request = _GA_http_requestPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Refresh the sessions internal cache of Liquid asset information.
  ///
  /// :param session: The session to use.
  /// :param params: the :ref:`assets-params-data` of the server to connect to.
  /// :param output: Destination for the assets JSON.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  ///
  /// Each release of GDK comes with a list of the latest registered Liquid
  /// assets built-in. This call is used to return this data and/or to update
  /// it to include any new assets that have been registered since installation
  /// or the last update.
  int GA_refresh_assets(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> params,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_refresh_assets(
      session,
      params,
      output,
    );
  }

  late final _GA_refresh_assetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_refresh_assets');
  late final _GA_refresh_assets = _GA_refresh_assetsPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Validate asset domain name.
  /// (This is a interface stub)
  int GA_validate_asset_domain_name(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> params,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_validate_asset_domain_name(
      session,
      params,
      output,
    );
  }

  late final _GA_validate_asset_domain_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_json>>)>>(
      'GA_validate_asset_domain_name');
  late final _GA_validate_asset_domain_name =
      _GA_validate_asset_domain_namePtr.asFunction<
          int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Create a new user wallet.
  ///
  /// :param session: The session to use.
  /// :param hw_device: :ref:`hw-device` or empty JSON for software wallet registration.
  /// :param details: The :ref:`login-credentials` for software wallet registration.
  /// :param call: Destination for the resulting GA_auth_handler to perform the registration.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_register_user(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> hw_device,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_register_user(
      session,
      hw_device,
      details,
      call,
    );
  }

  late final _GA_register_userPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GA_session>,
              ffi.Pointer<GA_json>,
              ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>('GA_register_user');
  late final _GA_register_user = _GA_register_userPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<GA_json>, ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Authenticate to a user's wallet.
  ///
  /// :param session: The session to use.
  /// :param hw_device: :ref:`hw-device` or empty JSON for software wallet login.
  /// :param details: The :ref:`login-credentials` for authenticating the user.
  /// :param call: Destination for the resulting GA_auth_handler to perform the login.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  ///
  /// If a sessions underlying network connection has disconnected and
  /// reconnected, the user will need to login again using this function. In
  /// this case, the caller can pass empty JSON for both ``hw_device`` and
  /// ``details`` to login using the previously passed credentials and device.
  int GA_login_user(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> hw_device,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_login_user(
      session,
      hw_device,
      details,
      call,
    );
  }

  late final _GA_login_userPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<GA_session>,
              ffi.Pointer<GA_json>,
              ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>('GA_login_user');
  late final _GA_login_user = _GA_login_userPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<GA_json>, ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Set or disable a watch-only login for a logged-in user wallet.
  ///
  /// :param session: The session to use.
  /// :param username: The watch-only username to login with, or a blank string to disable.
  /// :param password: The watch-only password to login with, or a blank string to disable.
  int GA_set_watch_only(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> password,
  ) {
    return _GA_set_watch_only(
      session,
      username,
      password,
    );
  }

  late final _GA_set_watch_onlyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('GA_set_watch_only');
  late final _GA_set_watch_only = _GA_set_watch_onlyPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>)>();

  /// Get the current watch-only login for a logged-in user wallet, if any.
  ///
  /// :param session: The session to use.
  /// :param username: Destination for the watch-only username. Empty string if not set.
  /// |     Returned string should be freed using `GA_destroy_string`.
  int GA_get_watch_only_username(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> username,
  ) {
    return _GA_get_watch_only_username(
      session,
      username,
    );
  }

  late final _GA_get_watch_only_usernamePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>,
                  ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'GA_get_watch_only_username');
  late final _GA_get_watch_only_username =
      _GA_get_watch_only_usernamePtr.asFunction<
          int Function(
              ffi.Pointer<GA_session>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Remove and delete the server history of a wallet.
  ///
  /// :param session: The session to use.
  /// :param call: Destination for the resulting GA_auth_handler to perform the removal.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  ///
  /// For multisig Green sessions, removing a wallet removes all history and
  /// data associated with the wallet on the server. This operation cannot be
  /// undone, and re-registering the wallet will not bring back the wallet's
  /// history. For this reason, only empty wallets can be deleted.
  ///
  /// For singlesig sessions, removing a wallet removes the locally persisted cache.
  /// The actual removal will happen after `GA_destroy_session` is called.
  int GA_remove_account(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_remove_account(
      session,
      call,
    );
  }

  late final _GA_remove_accountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>('GA_remove_account');
  late final _GA_remove_account = _GA_remove_accountPtr.asFunction<
      int Function(ffi.Pointer<GA_session>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Create a subaccount.
  ///
  /// :param session: The session to use.
  /// :param details: The subaccount ``"name"`` (which must not be already used in
  /// |     the wallet) and ``"type"`` (either ``"2of2"``, ``"2of2_no_recovery"`` or ``"2of3"``) must be
  /// |     populated. Type ``"2of2_no_recovery"`` is available only for Liquid networks and
  /// |     always requires both keys for spending. For type ``"2of3"`` the caller may provide
  /// |     either ``"recovery_mnemonic"`` or ``"recovery_xpub"`` if they do not wish to have a
  /// |     mnemonic passphrase generated automatically.
  /// |     All other fields are ignored.
  /// :param call: Destination for the resulting GA_auth_handler to perform the creation.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  /// |     Details of the created subaccount are returned in the ``"result"`` element of
  /// |     the GA_auth_handler. For 2of3 subaccounts the field ``"recovery_xpub"`` will
  /// |     be populated, and ``"recovery_mnemonic"`` will contain the recovery mnemonic
  /// |     passphrase if one was generated. These values must be stored safely by the
  /// |     caller as they will not be returned again by any call such as `GA_get_subaccounts`.
  int GA_create_subaccount(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_create_subaccount(
      session,
      details,
      call,
    );
  }

  late final _GA_create_subaccountPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_create_subaccount');
  late final _GA_create_subaccount = _GA_create_subaccountPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get the user's subaccount details.
  ///
  /// :param session: The session to use.
  /// :param details: the :ref:`get-subaccounts-params-data` controlling the request.
  /// :param call: Destination for the resulting GA_auth_handler to perform the creation.
  /// |     The call handlers result is :ref:`subaccount-list`.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_get_subaccounts(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_get_subaccounts(
      session,
      details,
      call,
    );
  }

  late final _GA_get_subaccountsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_get_subaccounts');
  late final _GA_get_subaccounts = _GA_get_subaccountsPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get subaccount details.
  ///
  /// :param session: The session to use.
  /// :param subaccount: The value of ``"pointer"`` from :ref:`subaccount-list` for the subaccount.
  /// :param call: Destination for the resulting GA_auth_handler to perform the creation.
  /// |     The call handlers result is :ref:`subaccount-detail`.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_get_subaccount(
    ffi.Pointer<GA_session> session,
    int subaccount,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_get_subaccount(
      session,
      subaccount,
      call,
    );
  }

  late final _GA_get_subaccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Uint32,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>('GA_get_subaccount');
  late final _GA_get_subaccount = _GA_get_subaccountPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, int,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Rename a subaccount.
  ///
  /// :param session: The session to use.
  /// :param subaccount: The value of ``"pointer"`` from :ref:`subaccount-list` or
  /// |                   :ref:`subaccount-detail` for the subaccount to rename.
  /// :param new_name: New name for the subaccount.
  ///
  /// .. note:: This call is deprecated and will be removed in a future release. Use
  /// |          `GA_update_subaccount` to rename subaccounts.
  int GA_rename_subaccount(
    ffi.Pointer<GA_session> session,
    int subaccount,
    ffi.Pointer<ffi.Int8> new_name,
  ) {
    return _GA_rename_subaccount(
      session,
      subaccount,
      new_name,
    );
  }

  late final _GA_rename_subaccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Uint32,
              ffi.Pointer<ffi.Int8>)>>('GA_rename_subaccount');
  late final _GA_rename_subaccount = _GA_rename_subaccountPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, int, ffi.Pointer<ffi.Int8>)>();

  /// Update subaccount information.
  ///
  /// :param session: The session to use.
  /// :param details: :ref:`subaccount-update` giving the details to update.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_update_subaccount(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_update_subaccount(
      session,
      details,
      call,
    );
  }

  late final _GA_update_subaccountPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_update_subaccount');
  late final _GA_update_subaccount = _GA_update_subaccountPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get a page of the user's transaction history.
  ///
  /// :param session: The session to use.
  /// :param details: :ref:`transactions-details` giving the details to get the transactions for.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  ///
  /// .. note:: Transactions are returned from newest to oldest with up to 30 transactions per page.
  int GA_get_transactions(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_get_transactions(
      session,
      details,
      call,
    );
  }

  late final _GA_get_transactionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_get_transactions');
  late final _GA_get_transactions = _GA_get_transactionsPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get a new address to receive coins to.
  ///
  /// :param session: The session to use.
  /// :param details: :ref:`receive-address-details`.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_get_receive_address(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_get_receive_address(
      session,
      details,
      call,
    );
  }

  late final _GA_get_receive_addressPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_get_receive_address');
  late final _GA_get_receive_address = _GA_get_receive_addressPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get a page of addresses previously generated for a subaccount.
  ///
  /// :param session: The session to use.
  /// :param details: :ref:`previous-addresses-request` detailing the previous addresses to fetch.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     The call handlers result is :ref:`previous-addresses`.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  ///
  /// .. note:: Iteration of all addresses is complete when 'last_pointer' is not
  /// |     present in the results.
  int GA_get_previous_addresses(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_get_previous_addresses(
      session,
      details,
      call,
    );
  }

  late final _GA_get_previous_addressesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_get_previous_addresses');
  late final _GA_get_previous_addresses =
      _GA_get_previous_addressesPtr.asFunction<
          int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get the user's unspent transaction outputs.
  ///
  /// :param session: The session to use.
  /// :param details: :ref:`unspent-outputs-request` detailing the unspent transaction outputs to fetch.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     The call handlers result is :ref:`unspent-outputs`.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_get_unspent_outputs(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_get_unspent_outputs(
      session,
      details,
      call,
    );
  }

  late final _GA_get_unspent_outputsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_get_unspent_outputs');
  late final _GA_get_unspent_outputs = _GA_get_unspent_outputsPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get the unspent transaction outputs associated with a non-wallet private key.
  ///
  /// :param session: The session to use.
  /// :param key: The private key in WIF or BIP 38 format.
  /// :param password: The password the key is encrypted with, if any.
  /// :param unused: unused, must be 0
  /// :param utxos: Destination for the returned utxos (same format as :ref:`tx-list`).
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  ///
  /// .. note:: Neither the private key or its derived public key are transmitted.
  int GA_get_unspent_outputs_for_private_key(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> private_key,
    ffi.Pointer<ffi.Int8> password,
    int unused,
    ffi.Pointer<ffi.Pointer<GA_json>> utxos,
  ) {
    return _GA_get_unspent_outputs_for_private_key(
      session,
      private_key,
      password,
      unused,
      utxos,
    );
  }

  late final _GA_get_unspent_outputs_for_private_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<GA_session>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Uint32,
                  ffi.Pointer<ffi.Pointer<GA_json>>)>>(
      'GA_get_unspent_outputs_for_private_key');
  late final _GA_get_unspent_outputs_for_private_key =
      _GA_get_unspent_outputs_for_private_keyPtr.asFunction<
          int Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>, int, ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Change the status of a user's unspent transaction outputs.
  ///
  /// :param session: The session to use.
  /// :param details: :ref:`unspent-outputs-status` detailing the unspent transaction outputs status to set.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_set_unspent_outputs_status(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_set_unspent_outputs_status(
      session,
      details,
      call,
    );
  }

  late final _GA_set_unspent_outputs_statusPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_set_unspent_outputs_status');
  late final _GA_set_unspent_outputs_status =
      _GA_set_unspent_outputs_statusPtr.asFunction<
          int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get a transaction's details.
  ///
  /// :param session: The session to use.
  /// :param txhash_hex: The transaction hash of the transaction to fetch.
  /// :param transaction: Destination for the :ref:`external-tx-detail`.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_get_transaction_details(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> txhash_hex,
    ffi.Pointer<ffi.Pointer<GA_json>> transaction,
  ) {
    return _GA_get_transaction_details(
      session,
      txhash_hex,
      transaction,
    );
  }

  late final _GA_get_transaction_detailsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<GA_json>>)>>(
      'GA_get_transaction_details');
  late final _GA_get_transaction_details =
      _GA_get_transaction_detailsPtr.asFunction<
          int Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Get the sum of unspent outputs paying to a subaccount.
  ///
  /// :param session: The session to use.
  /// :param details: :ref:`unspent-outputs-request` detailing the unspent transaction outputs to
  /// |    compute the balance from.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_get_balance(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_get_balance(
      session,
      details,
      call,
    );
  }

  late final _GA_get_balancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>('GA_get_balance');
  late final _GA_get_balance = _GA_get_balancePtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get the list of allowed currencies for all available pricing sources.
  ///
  /// :param session: The session to use.
  /// :param currencies: The returned list of :ref:`currencies`.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_get_available_currencies(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<GA_json>> currencies,
  ) {
    return _GA_get_available_currencies(
      session,
      currencies,
    );
  }

  late final _GA_get_available_currenciesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<GA_session>, ffi.Pointer<ffi.Pointer<GA_json>>)>>(
      'GA_get_available_currencies');
  late final _GA_get_available_currencies =
      _GA_get_available_currenciesPtr.asFunction<
          int Function(
              ffi.Pointer<GA_session>, ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Convert Fiat to BTC and vice-versa.
  ///
  /// :param session: The session to use.
  /// :param value_details: :ref:`convert-amount` giving the value to convert.
  /// :param output: Destination for the converted values :ref:`amount-data`.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_convert_amount(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> value_details,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_convert_amount(
      session,
      value_details,
      output,
    );
  }

  late final _GA_convert_amountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_convert_amount');
  late final _GA_convert_amount = _GA_convert_amountPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Encrypt json with server provided key protected by a PIN.
  ///
  /// :param session: The session to use.
  /// :param details: The :ref:`encrypt-with-pin-details` to encrypt.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     The call handlers result is :ref:`encrypt-with-pin-result` which the caller should persist.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_encrypt_with_pin(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_encrypt_with_pin(
      session,
      details,
      call,
    );
  }

  late final _GA_encrypt_with_pinPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_encrypt_with_pin');
  late final _GA_encrypt_with_pin = _GA_encrypt_with_pinPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Disable all PIN logins previously set.
  ///
  /// After calling this method, the user will not be able to login with PIN
  /// | from any device that was previously enabled using `GA_encrypt_with_pin`.
  ///
  /// :param session: The session to use.
  int GA_disable_all_pin_logins(
    ffi.Pointer<GA_session> session,
  ) {
    return _GA_disable_all_pin_logins(
      session,
    );
  }

  late final _GA_disable_all_pin_loginsPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GA_session>)>>(
          'GA_disable_all_pin_logins');
  late final _GA_disable_all_pin_logins = _GA_disable_all_pin_loginsPtr
      .asFunction<int Function(ffi.Pointer<GA_session>)>();

  /// Construct a transaction.
  ///
  /// :param session: The session to use.
  /// :param transaction_details: The :ref:`create-tx-details` for constructing.
  /// :param call: Destination for the resulting GA_auth_handler to complete the action.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_create_transaction(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> transaction_details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_create_transaction(
      session,
      transaction_details,
      call,
    );
  }

  late final _GA_create_transactionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_create_transaction');
  late final _GA_create_transaction = _GA_create_transactionPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Sign the user's inputs to a transaction.
  ///
  /// :param session: The session to use.
  /// :param transaction_details: The :ref:`sign-tx-details` for signing, previously returned from GA_create_transaction.
  /// :param call: Destination for the resulting GA_auth_handler to perform the signing.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_sign_transaction(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> transaction_details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_sign_transaction(
      session,
      transaction_details,
      call,
    );
  }

  late final _GA_sign_transactionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_sign_transaction');
  late final _GA_sign_transaction = _GA_sign_transactionPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Sign one or more of a user's inputs in a PSBT or PSET.
  ///
  /// :param session: The session to use.
  /// :param details: The :ref:`sign-psbt-details` for signing.
  /// :param call: Destination for the resulting GA_auth_handler to perform the signing.
  /// |     The call handlers result is :ref:`sign-psbt-result`.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  ///
  /// .. note:: EXPERIMENTAL warning: this call may be changed in future releases.
  int GA_psbt_sign(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_psbt_sign(
      session,
      details,
      call,
    );
  }

  late final _GA_psbt_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>('GA_psbt_sign');
  late final _GA_psbt_sign = _GA_psbt_signPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get wallet details of a PSBT or PSET.
  ///
  /// :param session: The session to use.
  /// :param details: The :ref:`psbt-wallet-details` for getting the wallet details.
  /// :param call: Destination for the resulting GA_auth_handler to get the wallet details.
  /// |     The call handlers result is :ref:`psbt-get-details-result`.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  ///
  /// .. note:: EXPERIMENTAL warning: this call may be changed in future releases.
  int GA_psbt_get_details(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_psbt_get_details(
      session,
      details,
      call,
    );
  }

  late final _GA_psbt_get_detailsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_psbt_get_details');
  late final _GA_psbt_get_details = _GA_psbt_get_detailsPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Broadcast a fully signed transaction to the P2P network.
  ///
  /// :param session: The session to use.
  /// :param transaction_hex: The signed transaction in hex to broadcast.
  /// :param tx_hash: Destination for the resulting transactions hash.
  /// |     Returned string should be freed using `GA_destroy_string`.
  int GA_broadcast_transaction(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> transaction_hex,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> tx_hash,
  ) {
    return _GA_broadcast_transaction(
      session,
      transaction_hex,
      tx_hash,
    );
  }

  late final _GA_broadcast_transactionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('GA_broadcast_transaction');
  late final _GA_broadcast_transaction =
      _GA_broadcast_transactionPtr.asFunction<
          int Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Send a transaction created by GA_create_transaction and signed by GA_sign_transaction.
  ///
  /// :param session: The session to use.
  /// :param transaction_details: The :ref:`send-tx-details` for sending.
  /// :param call: Destination for the resulting GA_auth_handler to perform the send.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_send_transaction(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> transaction_details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_send_transaction(
      session,
      transaction_details,
      call,
    );
  }

  late final _GA_send_transactionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_send_transaction');
  late final _GA_send_transaction = _GA_send_transactionPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Request an email containing the user's nLockTime transactions.
  ///
  /// :param session: The session to use.
  int GA_send_nlocktimes(
    ffi.Pointer<GA_session> session,
  ) {
    return _GA_send_nlocktimes(
      session,
    );
  }

  late final _GA_send_nlocktimesPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GA_session>)>>(
          'GA_send_nlocktimes');
  late final _GA_send_nlocktimes = _GA_send_nlocktimesPtr.asFunction<
      int Function(ffi.Pointer<GA_session>)>();

  /// Set the number of blocks after which CSV transactions become spendable without two factor authentication.
  ///
  /// :param session: The session to use.
  /// :param locktime_details: The :ref:`set-locktime-details` for setting the block value.
  /// :param call: Destination for the resulting GA_auth_handler to change the locktime.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_set_csvtime(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> locktime_details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_set_csvtime(
      session,
      locktime_details,
      call,
    );
  }

  late final _GA_set_csvtimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>('GA_set_csvtime');
  late final _GA_set_csvtime = _GA_set_csvtimePtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Set the number of blocks after which nLockTime transactions become
  /// |    spendable without two factor authentication. When this call
  /// |    succeeds, if the user has an email address associated with the
  /// |    wallet, an updated nlocktimes.zip file will be sent via email.
  ///
  /// :param session: The session to use.
  /// :param locktime_details: The :ref:`set-locktime-details` for setting the block value.
  /// :param call: Destination for the resulting GA_auth_handler to change the locktime.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_set_nlocktime(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> locktime_details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_set_nlocktime(
      session,
      locktime_details,
      call,
    );
  }

  late final _GA_set_nlocktimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>('GA_set_nlocktime');
  late final _GA_set_nlocktime = _GA_set_nlocktimePtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Add a transaction memo to a user's GreenAddress transaction.
  ///
  /// :param session: The session to use.
  /// :param txhash_hex: The transaction hash to associate the memo with.
  /// :param memo: The memo to set.
  /// :param memo_type: Unused, pass 0.
  int GA_set_transaction_memo(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> txhash_hex,
    ffi.Pointer<ffi.Int8> memo,
    int memo_type,
  ) {
    return _GA_set_transaction_memo(
      session,
      txhash_hex,
      memo,
      memo_type,
    );
  }

  late final _GA_set_transaction_memoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>, ffi.Uint32)>>('GA_set_transaction_memo');
  late final _GA_set_transaction_memo = _GA_set_transaction_memoPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>, int)>();

  /// Get the current network's fee estimates.
  ///
  /// :param session: The session to use.
  /// :param estimates: Destination for the returned :ref:`estimates`.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  ///
  /// The estimates are returned as an array of 25 elements. Each element is
  /// an integer representing the fee estimate expressed as satoshi per 1000
  /// bytes. The first element is the minimum relay fee as returned by the
  /// network, while the remaining elements are the current estimates to use
  /// for a transaction to confirm from 1 to 24 blocks.
  int GA_get_fee_estimates(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<GA_json>> estimates,
  ) {
    return _GA_get_fee_estimates(
      session,
      estimates,
    );
  }

  late final _GA_get_fee_estimatesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_get_fee_estimates');
  late final _GA_get_fee_estimates = _GA_get_fee_estimatesPtr.asFunction<
      int Function(
          ffi.Pointer<GA_session>, ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Get the user's credentials.
  ///
  /// :param session: The session to use.
  /// :param details: The :ref:`get-credentials-details` to get the credentials.
  /// :param call: Destination for the resulting GA_auth_handler to get the user's credentials.
  /// |     The call handlers result is :ref:`login-credentials`.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_get_credentials(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_get_credentials(
      session,
      details,
      call,
    );
  }

  late final _GA_get_credentialsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_get_credentials');
  late final _GA_get_credentials = _GA_get_credentialsPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get the latest un-acknowledged system message.
  ///
  /// :param session: The session to use.
  /// :param message_text: The returned UTF-8 encoded message text.
  /// |     Returned string should be freed using `GA_destroy_string`.
  ///
  /// .. note:: If all current messages are acknowledged, an empty string is returned.
  int GA_get_system_message(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> message_text,
  ) {
    return _GA_get_system_message(
      session,
      message_text,
    );
  }

  late final _GA_get_system_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('GA_get_system_message');
  late final _GA_get_system_message = _GA_get_system_messagePtr.asFunction<
      int Function(
          ffi.Pointer<GA_session>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Sign and acknowledge a system message.
  ///
  /// The message text will be signed with a key derived from the wallet master key and the signature
  /// sent to the server.
  ///
  /// :param session: The session to use.
  /// :param message_text: UTF-8 encoded message text being acknowledged.
  /// :param call: Destination for the resulting GA_auth_handler to acknowledge the message.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_ack_system_message(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> message_text,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_ack_system_message(
      session,
      message_text,
      call,
    );
  }

  late final _GA_ack_system_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_ack_system_message');
  late final _GA_ack_system_message = _GA_ack_system_messagePtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get the two factor configuration for the current user.
  ///
  /// :param session: The session to use.
  /// :param config: Destination for the returned :ref:`twofactor_configuration`.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_get_twofactor_config(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<GA_json>> config,
  ) {
    return _GA_get_twofactor_config(
      session,
      config,
    );
  }

  late final _GA_get_twofactor_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_get_twofactor_config');
  late final _GA_get_twofactor_config = _GA_get_twofactor_configPtr.asFunction<
      int Function(
          ffi.Pointer<GA_session>, ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Change wallet settings.
  ///
  /// :param session: The session to use.
  /// :param settings: The new :ref:`settings` values.
  /// :param call: Destination for the resulting GA_auth_handler.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_change_settings(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> settings,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_change_settings(
      session,
      settings,
      call,
    );
  }

  late final _GA_change_settingsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_change_settings');
  late final _GA_change_settings = _GA_change_settingsPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Get current wallet settings.
  ///
  /// :param session: The session to use.
  /// :param settings: Destination for the current :ref:`settings`.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_get_settings(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<GA_json>> settings,
  ) {
    return _GA_get_settings(
      session,
      settings,
    );
  }

  late final _GA_get_settingsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_session>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_get_settings');
  late final _GA_get_settings = _GA_get_settingsPtr.asFunction<
      int Function(
          ffi.Pointer<GA_session>, ffi.Pointer<ffi.Pointer<GA_json>>)>();

  int GA_convert_json_to_string(
    ffi.Pointer<GA_json> json,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> output,
  ) {
    return _GA_convert_json_to_string(
      json,
      output,
    );
  }

  late final _GA_convert_json_to_stringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<GA_json>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'GA_convert_json_to_string');
  late final _GA_convert_json_to_string =
      _GA_convert_json_to_stringPtr.asFunction<
          int Function(
              ffi.Pointer<GA_json>, ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int GA_convert_string_to_json(
    ffi.Pointer<ffi.Int8> input,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_convert_string_to_json(
      input,
      output,
    );
  }

  late final _GA_convert_string_to_jsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_convert_string_to_json');
  late final _GA_convert_string_to_json =
      _GA_convert_string_to_jsonPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Pointer<GA_json>>)>();

  int GA_convert_json_value_to_string(
    ffi.Pointer<GA_json> json,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> output,
  ) {
    return _GA_convert_json_value_to_string(
      json,
      path,
      output,
    );
  }

  late final _GA_convert_json_value_to_stringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>(
      'GA_convert_json_value_to_string');
  late final _GA_convert_json_value_to_string =
      _GA_convert_json_value_to_stringPtr.asFunction<
          int Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  int GA_convert_json_value_to_uint32(
    ffi.Pointer<GA_json> json,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Uint32> output,
  ) {
    return _GA_convert_json_value_to_uint32(
      json,
      path,
      output,
    );
  }

  late final _GA_convert_json_value_to_uint32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint32>)>>('GA_convert_json_value_to_uint32');
  late final _GA_convert_json_value_to_uint32 =
      _GA_convert_json_value_to_uint32Ptr.asFunction<
          int Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint32>)>();

  int GA_convert_json_value_to_uint64(
    ffi.Pointer<GA_json> json,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Uint64> output,
  ) {
    return _GA_convert_json_value_to_uint64(
      json,
      path,
      output,
    );
  }

  late final _GA_convert_json_value_to_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint64>)>>('GA_convert_json_value_to_uint64');
  late final _GA_convert_json_value_to_uint64 =
      _GA_convert_json_value_to_uint64Ptr.asFunction<
          int Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint64>)>();

  int GA_convert_json_value_to_bool(
    ffi.Pointer<GA_json> json,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Uint32> output,
  ) {
    return _GA_convert_json_value_to_bool(
      json,
      path,
      output,
    );
  }

  late final _GA_convert_json_value_to_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint32>)>>('GA_convert_json_value_to_bool');
  late final _GA_convert_json_value_to_bool =
      _GA_convert_json_value_to_boolPtr.asFunction<
          int Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint32>)>();

  int GA_convert_json_value_to_json(
    ffi.Pointer<GA_json> json,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_convert_json_value_to_json(
      json,
      path,
      output,
    );
  }

  late final _GA_convert_json_value_to_jsonPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<GA_json>>)>>(
      'GA_convert_json_value_to_json');
  late final _GA_convert_json_value_to_json =
      _GA_convert_json_value_to_jsonPtr.asFunction<
          int Function(ffi.Pointer<GA_json>, ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Free a GA_json object.
  ///
  /// :param json: GA_json object to free.
  int GA_destroy_json(
    ffi.Pointer<GA_json> json,
  ) {
    return _GA_destroy_json(
      json,
    );
  }

  late final _GA_destroy_jsonPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GA_json>)>>(
          'GA_destroy_json');
  late final _GA_destroy_json =
      _GA_destroy_jsonPtr.asFunction<int Function(ffi.Pointer<GA_json>)>();

  /// Get the status/result of an action requiring authorization.
  ///
  /// :param call: The auth_handler whose status is to be queried.
  /// :param output: Destination for the resulting :ref:`auth-handler-status`.
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  ///
  /// Methods in the api that may require two factor or hardware authentication
  /// to complete return a GA_auth_handler object. This object encapsulates the
  /// process of determining whether authentication is required and handling
  /// conditions such as re-prompting and re-trying after an incorrect two
  /// factor code is entered.
  ///
  /// The object acts as a state machine which is stepped through by the caller
  /// until the desired action is completed. At each step, the current state can
  /// be determined and used to perform the next action required.
  ///
  /// Some actions require a sequence of codes and decisions; these are hidden
  /// behind the state machine interface so that callers do not need to handle
  /// special cases or program their own logic to handle any lower level API
  /// differences.
  ///
  /// The state machine has the following states, which are returned in the
  /// ``"status"`` element from `GA_auth_handler_get_status`:
  ///
  /// * ``"done"``: The action has been completed successfully. Any data returned
  /// |  from the action is present in the ``"result"`` element of the status JSON.
  /// | The auth_handler object should be destroyed using `GA_destroy_auth_handler`
  /// | after receiving this status.
  ///
  /// * ``"error"``: A non-recoverable error occurred performing the action. The
  /// | associated error message is given in the status element ``"error"``. The
  /// | auth_handler object should be destroyed using `GA_destroy_auth_handler` and
  /// | the action restarted from scratch if this state is returned.
  ///
  /// * ``"request_code"``: Two factor authorization is required. The caller should
  /// | prompt the user to choose a two factor method from the ``"methods"`` element
  /// | and call `GA_auth_handler_request_code` with the selected method.
  ///
  /// * ``"resolve_code"``: A twofactor code from the ``"request_code"`` step, or
  /// | data from a hardware device is required. If the status JSON contains
  /// | :ref:`hw-required-data`, then see :ref:`hw-resolve-overview` for details.
  /// | Otherwise, to resolve a twofactor code, the caller should prompt the user
  /// | to enter the code from the twofactor method chosen in the ``"request_code"``
  /// | step, and pass this code to `GA_auth_handler_resolve_code`.
  ///
  /// * ``"call"``: Twofactor or hardware authorization is complete and the caller
  /// | should call `GA_auth_handler_call` to perform the action.
  int GA_auth_handler_get_status(
    ffi.Pointer<GA_auth_handler> call,
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_auth_handler_get_status(
      call,
      output,
    );
  }

  late final _GA_auth_handler_get_statusPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_auth_handler>,
                  ffi.Pointer<ffi.Pointer<GA_json>>)>>(
      'GA_auth_handler_get_status');
  late final _GA_auth_handler_get_status =
      _GA_auth_handler_get_statusPtr.asFunction<
          int Function(ffi.Pointer<GA_auth_handler>,
              ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Request a two factor authentication code to authorize an action.
  ///
  /// :param call: The auth_handler representing the action to perform.
  /// :param method: The selected two factor method to use
  int GA_auth_handler_request_code(
    ffi.Pointer<GA_auth_handler> call,
    ffi.Pointer<ffi.Int8> method,
  ) {
    return _GA_auth_handler_request_code(
      call,
      method,
    );
  }

  late final _GA_auth_handler_request_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_auth_handler>,
              ffi.Pointer<ffi.Int8>)>>('GA_auth_handler_request_code');
  late final _GA_auth_handler_request_code =
      _GA_auth_handler_request_codePtr.asFunction<
          int Function(ffi.Pointer<GA_auth_handler>, ffi.Pointer<ffi.Int8>)>();

  /// Authorize an action by providing its previously requested two factor authentication code.
  ///
  /// :param call: The auth_handler representing the action to perform.
  /// :param code: The two factor authentication code received by the user, or
  /// |    the serialised JSON response for hardware interaction (see :ref:`hw-resolve-overview`).
  int GA_auth_handler_resolve_code(
    ffi.Pointer<GA_auth_handler> call,
    ffi.Pointer<ffi.Int8> code,
  ) {
    return _GA_auth_handler_resolve_code(
      call,
      code,
    );
  }

  late final _GA_auth_handler_resolve_codePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<GA_auth_handler>,
              ffi.Pointer<ffi.Int8>)>>('GA_auth_handler_resolve_code');
  late final _GA_auth_handler_resolve_code =
      _GA_auth_handler_resolve_codePtr.asFunction<
          int Function(ffi.Pointer<GA_auth_handler>, ffi.Pointer<ffi.Int8>)>();

  /// Perform an action following the completion of authorization.
  ///
  /// :param call: The auth_handler representing the action to perform.
  int GA_auth_handler_call(
    ffi.Pointer<GA_auth_handler> call,
  ) {
    return _GA_auth_handler_call(
      call,
    );
  }

  late final _GA_auth_handler_callPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GA_auth_handler>)>>(
      'GA_auth_handler_call');
  late final _GA_auth_handler_call = _GA_auth_handler_callPtr.asFunction<
      int Function(ffi.Pointer<GA_auth_handler>)>();

  /// Free an auth_handler after use.
  ///
  /// :param call: The auth_handler to free.
  int GA_destroy_auth_handler(
    ffi.Pointer<GA_auth_handler> call,
  ) {
    return _GA_destroy_auth_handler(
      call,
    );
  }

  late final _GA_destroy_auth_handlerPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<GA_auth_handler>)>>(
      'GA_destroy_auth_handler');
  late final _GA_destroy_auth_handler = _GA_destroy_auth_handlerPtr.asFunction<
      int Function(ffi.Pointer<GA_auth_handler>)>();

  /// Enable or disable a two factor authentication method.
  ///
  /// :param session: The session to use
  /// :param method: The two factor method to enable/disable, i.e. ``"email"``, ``"sms"``, ``"phone"``, ``"gauth"``
  /// :param twofactor_details: The two factor method and associated data such as an email address. :ref:`twofactor-detail`
  /// :param call: Destination for the resulting GA_auth_handler to perform the action
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_change_settings_twofactor(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> method,
    ffi.Pointer<GA_json> twofactor_details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_change_settings_twofactor(
      session,
      method,
      twofactor_details,
      call,
    );
  }

  late final _GA_change_settings_twofactorPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<GA_session>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_change_settings_twofactor');
  late final _GA_change_settings_twofactor =
      _GA_change_settings_twofactorPtr.asFunction<
          int Function(
              ffi.Pointer<GA_session>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Request to begin the two factor authentication reset process.
  ///
  /// Returns the ``"twofactor_reset"`` portion of :ref:`twofactor_configuration` in
  /// the GA_auth_handler result.
  ///
  /// :param session: The session to use.
  /// :param email: The new email address to enable once the reset waiting period expires.
  /// :param is_dispute: GA_TRUE if the reset request is disputed, GA_FALSE otherwise.
  /// :param call: Destination for the resulting GA_auth_handler to request the reset.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_twofactor_reset(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> email,
    int is_dispute,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_twofactor_reset(
      session,
      email,
      is_dispute,
      call,
    );
  }

  late final _GA_twofactor_resetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
                  ffi.Uint32, ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_twofactor_reset');
  late final _GA_twofactor_reset = _GA_twofactor_resetPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>, int,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Undo a request to begin the two factor authentication reset process.
  ///
  /// Returns the ``"twofactor_reset"`` portion of :ref:`twofactor_configuration` in
  /// the GA_auth_handler result.
  ///
  /// :param session: The session to use.
  /// :param email: The email address to cancel the reset request for. Must be
  /// |     the email previously passed to `GA_twofactor_reset`.
  /// :param call: Destination for the resulting GA_auth_handler to request the reset.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  ///
  /// .. note:: Unlike `GA_twofactor_cancel_reset`, this call only removes the reset
  /// |     request associated with the given email. If other emails have requested
  /// |     a reset, the wallet will still remain locked following this call.
  int GA_twofactor_undo_reset(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Int8> email,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_twofactor_undo_reset(
      session,
      email,
      call,
    );
  }

  late final _GA_twofactor_undo_resetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_twofactor_undo_reset');
  late final _GA_twofactor_undo_reset = _GA_twofactor_undo_resetPtr.asFunction<
      int Function(ffi.Pointer<GA_session>, ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Cancel all two factor reset requests and unlock the wallet for normal operation.
  ///
  /// This call requires authentication using an existing wallet twofactor method.
  ///
  /// Returns the ``"twofactor_reset"`` portion of :ref:`twofactor_configuration` in
  /// the GA_auth_handler result.
  ///
  /// :param session: The session to use.
  /// :param call: Destination for the resulting GA_auth_handler to cancel the reset.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_twofactor_cancel_reset(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_twofactor_cancel_reset(
      session,
      call,
    );
  }

  late final _GA_twofactor_cancel_resetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_twofactor_cancel_reset');
  late final _GA_twofactor_cancel_reset =
      _GA_twofactor_cancel_resetPtr.asFunction<
          int Function(ffi.Pointer<GA_session>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Change twofactor limits settings.
  ///
  /// :param session: The session to use.
  /// :param limit_details: Details of the new :ref:`transaction-limits`
  /// :param call: Destination for the resulting GA_auth_handler to perform the change.
  /// |     Returned GA_auth_handler should be freed using `GA_destroy_auth_handler`.
  int GA_twofactor_change_limits(
    ffi.Pointer<GA_session> session,
    ffi.Pointer<GA_json> limit_details,
    ffi.Pointer<ffi.Pointer<GA_auth_handler>> call,
  ) {
    return _GA_twofactor_change_limits(
      session,
      limit_details,
      call,
    );
  }

  late final _GA_twofactor_change_limitsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
                  ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>>(
      'GA_twofactor_change_limits');
  late final _GA_twofactor_change_limits =
      _GA_twofactor_change_limitsPtr.asFunction<
          int Function(ffi.Pointer<GA_session>, ffi.Pointer<GA_json>,
              ffi.Pointer<ffi.Pointer<GA_auth_handler>>)>();

  /// Free a string returned by the api.
  ///
  /// :param str: The string to free.
  void GA_destroy_string(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _GA_destroy_string(
      str,
    );
  }

  late final _GA_destroy_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int8>)>>(
          'GA_destroy_string');
  late final _GA_destroy_string =
      _GA_destroy_stringPtr.asFunction<void Function(ffi.Pointer<ffi.Int8>)>();

  /// Get up to 32 random bytes.
  ///
  /// Generate up to 32 random bytes using the same strategy as Bitcoin Core code.
  ///
  /// :param output_bytes: bytes output buffer
  /// :param siz: Number of bytes to return (max. 32)
  int GA_get_random_bytes(
    int num_bytes,
    ffi.Pointer<ffi.Uint8> output_bytes,
    int len,
  ) {
    return _GA_get_random_bytes(
      num_bytes,
      output_bytes,
      len,
    );
  }

  late final _GA_get_random_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              size_t, ffi.Pointer<ffi.Uint8>, size_t)>>('GA_get_random_bytes');
  late final _GA_get_random_bytes = _GA_get_random_bytesPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Generate a new random BIP 39 mnemonic.
  ///
  /// :param output: The generated mnemonic phrase.
  /// |     Returned string should be freed using `GA_destroy_string`.
  int GA_generate_mnemonic(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> output,
  ) {
    return _GA_generate_mnemonic(
      output,
    );
  }

  late final _GA_generate_mnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('GA_generate_mnemonic');
  late final _GA_generate_mnemonic = _GA_generate_mnemonicPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Generate a new random 12 word BIP 39 mnemonic.
  ///
  /// :param output: The generated mnemonic phrase.
  /// |     Returned string should be freed using `GA_destroy_string`.
  int GA_generate_mnemonic_12(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> output,
  ) {
    return _GA_generate_mnemonic_12(
      output,
    );
  }

  late final _GA_generate_mnemonic_12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<ffi.Int8>>)>>('GA_generate_mnemonic_12');
  late final _GA_generate_mnemonic_12 = _GA_generate_mnemonic_12Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Int8>>)>();

  /// Validate a BIP 39 mnemonic.
  ///
  /// :param mnemonic: The mnemonic phrase
  /// :param valid: Destination for the result: GA_TRUE if the mnemonic is valid else GA_FALSE
  int GA_validate_mnemonic(
    ffi.Pointer<ffi.Int8> mnemonic,
    ffi.Pointer<ffi.Uint32> valid,
  ) {
    return _GA_validate_mnemonic(
      mnemonic,
      valid,
    );
  }

  late final _GA_validate_mnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Uint32>)>>('GA_validate_mnemonic');
  late final _GA_validate_mnemonic = _GA_validate_mnemonicPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Uint32>)>();

  /// Register a network configuration
  ///
  /// :param name: The name of the network to register
  /// :param network_details: The :ref:`network` configuration to register
  ///
  /// Any existing configuration with the same name is overwritten.
  /// If the provided JSON is empty, any existing configuration for
  /// the network is removed.
  int GA_register_network(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<GA_json> network_details,
  ) {
    return _GA_register_network(
      name,
      network_details,
    );
  }

  late final _GA_register_networkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>,
              ffi.Pointer<GA_json>)>>('GA_register_network');
  late final _GA_register_network = _GA_register_networkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<GA_json>)>();

  /// Get the available network configurations
  ///
  /// :param output: Destination for the :ref:`networks-list`
  /// |     Returned GA_json should be freed using `GA_destroy_json`.
  int GA_get_networks(
    ffi.Pointer<ffi.Pointer<GA_json>> output,
  ) {
    return _GA_get_networks(
      output,
    );
  }

  late final _GA_get_networksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<GA_json>>)>>('GA_get_networks');
  late final _GA_get_networks = _GA_get_networksPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<GA_json>>)>();

  /// Get a uint32_t in the range 0 to (upper_bound - 1) without bias
  ///
  /// :param output: Destination for the generated uint32_t.
  int GA_get_uniform_uint32_t(
    int upper_bound,
    ffi.Pointer<ffi.Uint32> output,
  ) {
    return _GA_get_uniform_uint32_t(
      upper_bound,
      output,
    );
  }

  late final _GA_get_uniform_uint32_tPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Uint32, ffi.Pointer<ffi.Uint32>)>>('GA_get_uniform_uint32_t');
  late final _GA_get_uniform_uint32_t = _GA_get_uniform_uint32_tPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Uint32>)>();
}

class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Int8> __mbstate8;

  @ffi.Int64()
  external int _mbstateL;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Int8> __opaque;
}

class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Int8> __opaque;
}

class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int8> __opaque;
}

class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Int8> __opaque;
}

class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int8> __opaque;
}

class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int8> __opaque;
}

class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Int8> __opaque;
}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Int8> __opaque;
}

class _opaque_pthread_t extends ffi.Struct {
  @ffi.Int64()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Int8> __opaque;
}

class fd_set extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<__int32_t> fds_bits;
}

typedef __int32_t = ffi.Int32;

/// A server session
class GA_session extends ffi.Opaque {}

class GA_json extends ffi.Opaque {}

/// An api method call that potentially requires two factor authentication to complete
class GA_auth_handler extends ffi.Opaque {}

/// A notification handler
typedef GA_notification_handler = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<GA_json>)>>;
typedef size_t = __darwin_size_t;
typedef __darwin_size_t = ffi.Uint64;

const int __DARWIN_ONLY_64_BIT_INO_T = 0;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 0;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_64_BIT_INO_T = '\$INODE64';

const String __DARWIN_SUF_1050 = '\$1050';

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int __API_TO_BE_DEPRECATED = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_12_0 = 120000;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 120000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 120100;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_FD_SETSIZE = 1024;

const int __DARWIN_NBBY = 8;

const int __DARWIN_NFDBITS = 32;

const int NBBY = 8;

const int NFDBITS = 32;

const int FD_SETSIZE = 1024;

const int GA_OK = 0;

const int GA_ERROR = -1;

const int GA_RECONNECT = -2;

const int GA_SESSION_LOST = -3;

const int GA_TIMEOUT = -4;

const int GA_NOT_AUTHORIZED = -5;

const int GA_NONE = 0;

const int GA_INFO = 1;

const int GA_DEBUG = 2;

const int GA_TRUE = 1;

const int GA_FALSE = 0;
